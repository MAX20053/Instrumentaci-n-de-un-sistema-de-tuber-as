/* Proyecto: Monitoreo de frecuencia y flujo con sensor YF-G1 y envío MQTT a ThingSpeak */

#include <WiFi.h>
#include <PubSubClient.h>

// ==== WiFi ====
const char espwifi_ssid[] = "A56 de Juan Pablo";
const char espwifi_pass[] = "12345678";
//const char espwifi_ssid[] = "TP-Link_504E";
//const char espwifi_pass[] = "91516008";

void espwifi_setup() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(espwifi_ssid, espwifi_pass);
  Serial.println("Conectando a la red Wifi");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(100);
  }
  Serial.println("\nConexión realizada con éxito");
  Serial.print("Dirección IP: ");
  Serial.println(WiFi.localIP());
}

// ==== MQTT ThingSpeak ====
const char espmqtt_broker[] = "mqtt3.thingspeak.com";
const int espmqtt_port = 1883;
const char espmqtt_user[] = "FQ4eDDwIEDINEgkEEhQKLis";
const char espmqtt_pass[] = "IypwqORGjaQmd7//we6gDVJu";
const char espmqtt_clientid[] = "FQ4eDDwIEDINEgkEEhQKLis";
WiFiClient espmqtt_wifiClient;
PubSubClient espmqtt_client(espmqtt_wifiClient);

bool conectado;
unsigned long impr_conect_mqtt = 0;

void espmqtt_subscribe() {}
void espmqtt_callback(char* _topic, unsigned char* _payload, unsigned int _payloadlength) {}
void espmqtt_setup() {
  delay(10);
  randomSeed(micros());
  espmqtt_client.setServer(espmqtt_broker, espmqtt_port);
  espmqtt_client.setCallback(espmqtt_callback);
  espmqtt_subscribe();
}

void espmqtt_loop() {
  if (!espmqtt_client.connected()) {
    espmqtt_client.connect(espmqtt_clientid, espmqtt_user, espmqtt_pass);
    if ((millis() - impr_conect_mqtt) >= 1000) {
      Serial.println("Conectando al servidor MQTT");
      impr_conect_mqtt = millis();
    }
    conectado = false;
    espmqtt_subscribe();
  }
  if (espmqtt_client.connected()) {
    if (!conectado) {
      Serial.println("Conectado con éxito");
      conectado = true;
    }
    espmqtt_client.loop();
  }
}

// ==== Sensor de flujo YF-G1 ====
const int pinFlujo = 32;
volatile unsigned long conteoPulsos = 0;
unsigned long tiempoAnteriorFlujo = 0;
float frecuencia = 0;
float flujo_Lmin = 0;
const float factor_calibracion = 1;  // Hz por L/min

void IRAM_ATTR contarPulsos() {
  conteoPulsos++;
}

// ==== Publicación MQTT ====
unsigned long frecuenciaPubl_ = 0;

void setup() {
  Serial.begin(115200);
  espwifi_setup();
  espmqtt_setup();

  pinMode(pinFlujo, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(pinFlujo), contarPulsos, RISING);
  Serial.println("Sensor de flujo YF-G1 inicializado");
}

void loop() {
  yield();
  espmqtt_loop();

  // ==== Cálculo de frecuencia y flujo cada segundo ====
  unsigned long tiempoActualFlujo = millis();
  if (tiempoActualFlujo - tiempoAnteriorFlujo >= 1000) {
    detachInterrupt(digitalPinToInterrupt(pinFlujo));

    frecuencia = conteoPulsos;  // Pulsos por segundo = Hz
    flujo_Lmin = frecuencia / factor_calibracion;

    Serial.print("Frecuencia: ");
    Serial.print(frecuencia);
    Serial.print(" Hz  | Flujo: ");
    Serial.print(flujo_Lmin, 2);
    Serial.println(" L/min");

    conteoPulsos = 0;
    tiempoAnteriorFlujo = tiempoActualFlujo;

    attachInterrupt(digitalPinToInterrupt(pinFlujo), contarPulsos, RISING);
  }

  // ==== Publicar frecuencia y flujo cada 2.5 segundos ====
  if (millis() - frecuenciaPubl_ > 2500) {
    frecuenciaPubl_ = millis();

    String payload = "field1=" + String(frecuencia, 0) + "&field2=" + String(flujo_Lmin, 2);
    espmqtt_client.publish("channels/3090766/publish", payload.c_str());

    Serial.println("Publicando a ThingSpeak: " + payload);
  }
}
